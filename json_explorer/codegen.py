"""
codegen.py

A multi-target schema code generator.

Input: JSON data. The schema, generated by the analyze_json() function (a nested dictionary
describing data types), will be passed to the generator class.
Output: generated code for multiple targets: Go, Python dataclasses, Pydantic, Java,
Rust (serde), TypeScript, OpenAPI, GraphQL.

Usage (programmatic):
    from codegen import MultiTargetGenerator
    gen = MultiTargetGenerator(schema, root_name="Data")
    go_code = gen.generate("go")
    java_code = gen.generate("java", config={"jackson": True, "lombok": True})

Usage (CLI):
    python codegen.py --input data.json --target java --root User --config lombok=true
    python codegen.py --input data.json --target java --config "lombok=true,jackson=true,package=com.example.model"
    python codegen.py --input data.json --generate-all --root ApiResponse

This module focuses on producing readable, idiomatic code and reuses type definitions
where possible.
"""

from __future__ import annotations
import re
import json
import logging
from typing import Any, Dict, Optional, Set, List, Union
from abc import ABC, abstractmethod
from dataclasses import dataclass


# --------------------- Configuration and Utilities ---------------------


@dataclass
class GeneratorConfig:
    """Configuration for code generators with target-specific options."""

    # Common options
    package: Optional[str] = None
    namespace: Optional[str] = None

    # Java specific
    jackson: bool = True
    validation: bool = False
    lombok: bool = False

    # Python specific
    use_dataclasses: bool = True
    generate_init: bool = True

    # TypeScript specific
    export_interfaces: bool = True
    strict_nulls: bool = True

    # Go specific
    json_tags: bool = True
    omitempty: bool = True

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "GeneratorConfig":
        """Create config from dictionary, converting string values appropriately."""
        processed = {}
        for key, value in config_dict.items():
            if isinstance(value, str) and value.lower() in ("true", "false"):
                processed[key] = value.lower() == "true"
            else:
                processed[key] = value
        return cls(**processed)


def pascal_case(name: str) -> str:
    """Convert string to PascalCase."""
    if not name:
        return "AutoGenerated"
    name = re.sub(r"[^0-9a-zA-Z_]+", "_", name)
    parts = [p for p in re.split(r"[_\-\s]+", name) if p]
    if not parts:
        return "AutoGenerated"
    if len(parts) == 1:
        word = parts[0]
        if word[0].isupper():
            return word
        else:
            return word[0].upper() + word[1:]
    return "".join(p.capitalize() for p in parts)


def camel_case(name: str) -> str:
    """Convert string to camelCase."""
    pascal = pascal_case(name)
    return pascal[0].lower() + pascal[1:] if pascal else "autoGenerated"


def snake_case(name: str) -> str:
    """Convert string to snake_case."""
    name = re.sub(r"[^0-9a-zA-Z_]+", "_", name)
    name = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", name)
    return name.lower()


def safe_ident(name: str, prefix: str = "field") -> str:
    """Create safe identifier, adding prefix if starts with number."""
    name = re.sub(r"[^0-9a-zA-Z_]+", "_", name)
    if re.match(r"^[0-9]", name):
        name = f"{prefix}_{name}"
    return name


# --------------------- Core: schema walker and registry ---------------------


class NameRegistry:
    """Keep track of generated type names and reuse where possible."""

    def __init__(self):
        self.map: Dict[str, str] = {}
        self.used: Set[str] = set()
        self.type_cache: Dict[str, str] = {}  # schema hash -> type name

    def register(self, suggested: str, schema_hash: Optional[str] = None) -> str:
        """Register a new type name, optionally with schema hash for reuse."""
        if schema_hash and schema_hash in self.type_cache:
            return self.type_cache[schema_hash]

        base = pascal_case(suggested)
        if not base:
            base = "AutoGenerated"
        name = base
        i = 1
        while name in self.used:
            i += 1
            name = f"{base}{i}"
        self.used.add(name)

        if schema_hash:
            self.type_cache[schema_hash] = name

        return name

    def get_cached_type(self, schema_hash: str) -> Optional[str]:
        """Get cached type name for schema hash."""
        return self.type_cache.get(schema_hash)


def generate_schema_hash(node: Dict[str, Any]) -> str:
    """Generate a simple hash for schema node to enable type reuse."""
    # This is a simplified hash - in production you might want something more robust
    return str(hash(str(sorted(node.items()))))


# --------------------- Generator base ---------------------


class Generator(ABC):
    """Base class for all code generators."""

    def __init__(
        self,
        schema: Dict[str, Any],
        root_name: str = "Root",
        config: Optional[GeneratorConfig] = None,
    ):
        self.schema = schema
        self.root_name = pascal_case(root_name)
        self.config = config or GeneratorConfig()
        self.registry = NameRegistry()
        self.defined: Dict[str, str] = {}  # typename -> definition string
        self.imports: Set[str] = set()
        self.logger = logging.getLogger(self.__class__.__name__)

    @abstractmethod
    def generate(self) -> str:
        """Generate code for the target language."""
        pass

    def is_primitive(self, t: str) -> bool:
        """Check if type is primitive."""
        return t in {
            "str",
            "int",
            "float",
            "bool",
            "NoneType",
            "unknown",
            "mixed",
            "conflict",
            "timestamp",
        }

    def add_import(self, import_stmt: str) -> None:
        """Add import statement."""
        self.imports.add(import_stmt)

    def get_imports_section(self) -> str:
        """Get formatted imports section."""
        if not self.imports:
            return ""
        return "\n".join(sorted(self.imports)) + "\n\n"


# --------------------- Language-specific Reserved Keywords ---------------------


class ReservedKeywords:
    """Reserved keywords for different languages."""

    JAVA = {
        "abstract",
        "assert",
        "boolean",
        "break",
        "byte",
        "case",
        "catch",
        "char",
        "class",
        "const",
        "continue",
        "default",
        "do",
        "double",
        "else",
        "enum",
        "extends",
        "final",
        "finally",
        "float",
        "for",
        "goto",
        "if",
        "implements",
        "import",
        "instanceof",
        "int",
        "interface",
        "long",
        "native",
        "new",
        "package",
        "private",
        "protected",
        "public",
        "return",
        "short",
        "static",
        "strictfp",
        "super",
        "switch",
        "synchronized",
        "this",
        "throw",
        "throws",
        "transient",
        "try",
        "void",
        "volatile",
        "while",
    }

    PYTHON = {
        "and",
        "as",
        "assert",
        "break",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "exec",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "in",
        "is",
        "lambda",
        "not",
        "or",
        "pass",
        "print",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield",
        "True",
        "False",
        "None",
    }

    GO = {
        "break",
        "case",
        "chan",
        "const",
        "continue",
        "default",
        "defer",
        "else",
        "fallthrough",
        "for",
        "func",
        "go",
        "goto",
        "if",
        "import",
        "interface",
        "map",
        "package",
        "range",
        "return",
        "select",
        "struct",
        "switch",
        "type",
        "var",
    }

    TYPESCRIPT = {
        "abstract",
        "any",
        "as",
        "boolean",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "constructor",
        "continue",
        "declare",
        "default",
        "delete",
        "do",
        "else",
        "enum",
        "export",
        "extends",
        "false",
        "finally",
        "for",
        "from",
        "function",
        "get",
        "if",
        "implements",
        "import",
        "in",
        "instanceof",
        "interface",
        "let",
        "module",
        "new",
        "null",
        "number",
        "of",
        "package",
        "private",
        "protected",
        "public",
        "require",
        "return",
        "set",
        "static",
        "string",
        "super",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "type",
        "typeof",
        "undefined",
        "var",
        "void",
        "while",
        "with",
        "yield",
    }

    RUST = {
        "as",
        "break",
        "const",
        "continue",
        "crate",
        "else",
        "enum",
        "extern",
        "false",
        "fn",
        "for",
        "if",
        "impl",
        "in",
        "let",
        "loop",
        "match",
        "mod",
        "move",
        "mut",
        "pub",
        "ref",
        "return",
        "self",
        "Self",
        "static",
        "struct",
        "super",
        "trait",
        "true",
        "type",
        "unsafe",
        "use",
        "where",
        "while",
    }


def safe_field_name(name: str, keywords: Set[str], suffix: str = "Field") -> str:
    """Generate safe field name avoiding reserved keywords."""
    safe_name = safe_ident(name)
    if safe_name.lower() in {k.lower() for k in keywords}:
        safe_name = safe_name + suffix
    return safe_name


# --------------------- Java Generator ---------------------


class JavaGenerator(Generator):
    """Java generator with proper POJO generation, Jackson support, and better type handling."""

    # Primitive types for required fields
    PRIMITIVE_MAP = {
        "str": "String",
        "int": "int",
        "float": "double",
        "bool": "boolean",
        "timestamp": "OffsetDateTime",
    }

    # Wrapper types for optional fields
    WRAPPER_MAP = {
        "str": "String",
        "int": "Integer",
        "float": "Double",
        "bool": "Boolean",
        "timestamp": "OffsetDateTime",
    }

    # Default values for primitives
    PRIMITIVE_DEFAULTS = {
        "int": "0",
        "double": "0.0",
        "boolean": "false",
    }

    def generate(self) -> str:
        """Generate complete Java code with proper imports and classes."""
        self.defined.clear()
        self.imports.clear()

        # Generate all classes
        root_type = self._render_node(self.root_name, self.schema)

        # Build output
        parts = []

        # Package declaration
        if self.config.package:
            parts.append(f"package {self.config.package};\n")

        # Imports
        if self.imports:
            parts.append(self.get_imports_section())

        # Generated classes
        for name in sorted(self.defined.keys()):
            parts.append(self.defined[name])
            parts.append("")

        return "\n".join(parts).strip()

    def _safe_field_name(self, name: str) -> str:
        """Convert to safe Java field name and handle reserved keywords."""
        return safe_field_name(name, ReservedKeywords.JAVA, "Field")

    def _get_java_type(self, node: dict, field_name: str = "") -> str:
        """Get appropriate Java type based on schema node."""
        node_type = node["type"]
        optional = node.get("optional", False)

        if node_type in self.PRIMITIVE_MAP:
            if optional or node_type == "str":
                return self.WRAPPER_MAP[node_type]
            else:
                return self.PRIMITIVE_MAP[node_type]
        elif node_type in {"unknown", "mixed", "conflict", "NoneType"}:
            return "Object"
        else:
            # Custom type - should be handled by _render_node
            return self._render_node(pascal_case(field_name or "Item"), node)

    def _render_node(self, name: str, node: dict) -> str:
        node_type = node["type"]

        if node_type == "object":
            return self._render_class(name, node)
        elif node_type == "list":
            return self._render_list_type(name, node)
        else:
            return self._get_java_type(node, name)

    def _render_class(self, class_name: str, node: dict) -> str:
        """Generate a complete Java class."""
        # Check for cached type
        schema_hash = generate_schema_hash(node)
        cached_type = self.registry.get_cached_type(schema_hash)
        if cached_type:
            return cached_type

        class_name = self.registry.register(class_name, schema_hash)

        if class_name in self.defined:
            return class_name

        children = node.get("children", {})

        # Setup imports based on configuration
        self._setup_imports(children)

        lines = []

        # Class-level annotations
        self._add_class_annotations(lines)

        # Class declaration
        lines.append(f"public class {class_name} {{")
        lines.append("")

        # Fields
        self._generate_fields(lines, children)

        # Generate methods if not using Lombok
        if not self.config.lombok:
            lines.extend(self._generate_constructors(class_name, children))
            lines.extend(self._generate_getters_setters(children))
            lines.extend(self._generate_utility_methods(class_name, children))

        lines.append("}")

        self.defined[class_name] = "\n".join(lines)
        return class_name

    def _setup_imports(self, children: dict) -> None:
        """Setup required imports based on field types and configuration."""
        if self.config.jackson:
            self.add_import("import com.fasterxml.jackson.annotation.JsonProperty;")
            self.add_import(
                "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;"
            )
        if self.config.validation:
            self.add_import("import javax.validation.constraints.*;")
        if self.config.lombok:
            self.add_import("import lombok.Data;")
            self.add_import("import lombok.NoArgsConstructor;")
            self.add_import("import lombok.AllArgsConstructor;")

        # Check if we need List or time imports
        needs_list = any(child["type"] == "list" for child in children.values())
        needs_time = any(child["type"] == "timestamp" for child in children.values())
        needs_objects = not self.config.lombok  # For equals/hashCode

        if needs_list:
            self.add_import("import java.util.List;")
        if needs_time:
            self.add_import("import java.time.OffsetDateTime;")
        if needs_objects:
            self.add_import("import java.util.Objects;")

    def _add_class_annotations(self, lines: List[str]) -> None:
        """Add class-level annotations."""
        if self.config.jackson:
            lines.append("@JsonIgnoreProperties(ignoreUnknown = true)")
        if self.config.lombok:
            lines.append("@Data")
            lines.append("@NoArgsConstructor")
            lines.append("@AllArgsConstructor")

    def _generate_fields(self, lines: List[str], children: dict) -> None:
        """Generate field declarations with appropriate annotations."""
        for field_key, field_node in children.items():
            field_name = self._safe_field_name(field_key)
            java_type = self._get_java_type(field_node, field_key)
            optional = field_node.get("optional", False)

            # Field annotations
            field_annotations = []

            if self.config.jackson and field_name != field_key:
                field_annotations.append(f'@JsonProperty("{field_key}")')

            if self.config.validation and not optional:
                if field_node["type"] == "str":
                    field_annotations.append("@NotBlank")
                else:
                    field_annotations.append("@NotNull")

            # Add annotations
            for annotation in field_annotations:
                lines.append(f"    {annotation}")

            # Field declaration
            lines.append(f"    private {java_type} {field_name};")
            lines.append("")

    def _render_list_type(self, name: str, node: dict) -> str:
        """Handle list types."""
        if "child_type" in node:
            element_type = self._get_java_type({"type": node["child_type"]})
        elif "child" in node:
            element_type = self._render_node(name + "Item", node["child"])
        else:
            element_type = "Object"

        self.add_import("import java.util.List;")
        return f"List<{element_type}>"

    def _generate_constructors(self, class_name: str, children: dict) -> List[str]:
        """Generate constructors."""
        lines = []

        # Default constructor
        lines.extend([f"    public {class_name}() {{", "    }", ""])

        # All-args constructor
        if children:
            params = []
            assignments = []

            for field_key, field_node in children.items():
                field_name = self._safe_field_name(field_key)
                java_type = self._get_java_type(field_node, field_key)
                params.append(f"{java_type} {field_name}")
                assignments.append(f"        this.{field_name} = {field_name};")

            lines.append(f"    public {class_name}({', '.join(params)}) {{")
            lines.extend(assignments)
            lines.extend(["    }", ""])

        return lines

    def _generate_getters_setters(self, children: dict) -> List[str]:
        """Generate getter and setter methods."""
        lines = []

        for field_key, field_node in children.items():
            field_name = self._safe_field_name(field_key)
            java_type = self._get_java_type(field_node, field_key)

            # Getter
            getter_name = f"get{field_name.capitalize()}"
            if java_type == "boolean":
                getter_name = f"is{field_name.capitalize()}"

            lines.extend(
                [
                    f"    public {java_type} {getter_name}() {{",
                    f"        return {field_name};",
                    "    }",
                    "",
                ]
            )

            # Setter
            lines.extend(
                [
                    f"    public void set{field_name.capitalize()}({java_type} {field_name}) {{",
                    f"        this.{field_name} = {field_name};",
                    "    }",
                    "",
                ]
            )

        return lines

    def _generate_utility_methods(self, class_name: str, children: dict) -> List[str]:
        """Generate toString, equals, and hashCode methods."""
        lines = []
        field_names = [self._safe_field_name(k) for k in children.keys()]

        if not field_names:
            return lines

        # toString
        field_strings = [f"{name}=" + "{" + name + "}" for name in field_names]
        format_str = f"{class_name}({', '.join(field_strings)})"
        lines.extend(
            [
                "    @Override",
                "    public String toString() {",
                f'        return "{format_str}";',
                "    }",
                "",
            ]
        )

        # equals and hashCode
        lines.extend(
            [
                "    @Override",
                "    public boolean equals(Object o) {",
                "        if (this == o) return true;",
                "        if (o == null || getClass() != o.getClass()) return false;",
                f"        {class_name} that = ({class_name}) o;",
                f"        return {' && '.join([f'Objects.equals({name}, that.{name})' for name in field_names])};",
                "    }",
                "",
                "    @Override",
                "    public int hashCode() {",
                f"        return Objects.hash({', '.join(field_names)});",
                "    }",
                "",
            ]
        )

        return lines


# --------------------- Other Generators ---------------------


class GoGenerator(Generator):
    """Go generator with configuration support."""

    MAP = {
        "str": "string",
        "int": "int",
        "float": "float64",
        "bool": "bool",
        "NoneType": "interface{}",
        "unknown": "interface{}",
        "mixed": "interface{}",
        "conflict": "interface{}",
        "timestamp": "time.Time",
    }

    def _map_prim(self, t: str) -> str:
        return self.MAP.get(t, "interface{}")

    def generate(self) -> str:
        root_type = self._render_node(self.root_name, self.schema, top_level=True)
        parts = ["package main\n", "// Generated by multi_schema_codegen\n"]

        if self._contains_timestamp(self.schema):
            parts.append('import "time"\n')

        parts.extend(
            self.defined.get(name) + "\n\n" for name in sorted(self.defined.keys())
        )
        parts.append(f"type {self.root_name} = {root_type}\n")
        return "\n".join(p for p in parts if p)

    def _contains_timestamp(self, node):
        if isinstance(node, dict):
            t = node.get("type")
            if t == "timestamp":
                return True
            if t == "object":
                return any(
                    self._contains_timestamp(c)
                    for c in node.get("children", {}).values()
                )
            if t == "list":
                if "child_type" in node:
                    return node["child_type"] == "timestamp"
                if "child" in node:
                    return self._contains_timestamp(node["child"])
        return False

    def _render_node(
        self, name: str, node: Dict[str, Any], top_level: bool = False
    ) -> str:
        t = node["type"]
        if t == "object":
            type_name = self.registry.register(name)
            if type_name in self.defined:
                return type_name
            fields = []
            for k, v in node.get("children", {}).items():
                field_name = pascal_case(k)
                go_type = self._render_node(field_name, v)

                if self.config.json_tags:
                    omit = (
                        ",omitempty"
                        if v.get("optional") and self.config.omitempty
                        else ""
                    )
                    tag = f'`json:"{k}{omit}"`'
                else:
                    tag = ""

                fields.append(f"\t{field_name} {go_type} {tag}")

            struct_def = f"type {type_name} struct {{\n" + "\n".join(fields) + "\n}"
            self.defined[type_name] = struct_def
            return type_name

        if t == "list":
            if "child_type" in node:
                return f"[]{self._map_prim(node['child_type'])}"
            if "child" in node:
                child = node["child"]
                child_name = name + "Item"
                return f"[]{self._render_node(child_name, child)}"
            return "[]interface{}"

        return self._map_prim(t)


class PythonDataclassGenerator(Generator):
    """Python generator with better configuration support."""

    MAP = {
        "str": "str",
        "int": "int",
        "float": "float",
        "bool": "bool",
        "NoneType": "Any",
        "unknown": "Any",
        "mixed": "Any",
        "conflict": "Any",
        "timestamp": "datetime.datetime",
    }

    def _map_prim(self, t: str) -> str:
        return self.MAP.get(t, "Any")

    def generate(self) -> str:
        """Generate either dataclasses or pydantic based on configuration."""
        if self.config.use_dataclasses:
            return self.generate_dataclasses()
        else:
            return self.generate_pydantic()

    def generate_dataclasses(self) -> str:
        self.defined.clear()
        root_type = self._render_node(self.root_name, self.schema, top_level=True)
        imports = [
            "from dataclasses import dataclass, field",
            "from typing import Optional, List, Any",
            "import datetime",
        ]
        parts = ["\n".join(imports), "\n"]
        for name in sorted(self.defined.keys()):
            parts.append(self.defined[name])
            parts.append("")
        parts.append(f"# Root alias\n{self.root_name} = {root_type}")
        return "\n".join(parts)

    def generate_pydantic(self) -> str:
        self.defined.clear()
        root_type = self._render_node(
            self.root_name, self.schema, top_level=True, pydantic=True
        )
        imports = [
            "from pydantic import BaseModel, Field",
            "from typing import Optional, List, Any",
            "import datetime",
        ]
        parts = ["\n".join(imports), "\n"]
        for name in sorted(self.defined.keys()):
            parts.append(self.defined[name])
            parts.append("")
        parts.append(f"# Root alias\n{self.root_name} = {root_type}")
        return "\n".join(parts)

    def _render_node(
        self,
        name: str,
        node: Dict[str, Any],
        top_level: bool = False,
        pydantic: bool = False,
    ) -> str:
        t = node["type"]
        if t == "object":
            cls_name = self.registry.register(name)
            if cls_name in self.defined:
                return cls_name
            lines = []
            base = "BaseModel" if pydantic else ""
            header = (
                f"class {cls_name}({base}):"
                if pydantic
                else f"@dataclass\nclass {cls_name}:"
            )
            for k, v in node.get("children", {}).items():
                field_name = safe_field_name(k, ReservedKeywords.PYTHON)
                child_type = self._render_node(pascal_case(k), v, pydantic=pydantic)
                optional = v.get("optional")
                ann = child_type
                if optional and not ann.startswith("Optional[") and ann != "Any":
                    ann = f"Optional[{ann}]"
                if pydantic:
                    default = " = None" if optional else ""
                    lines.append(f"    {field_name}: {ann}{default}")
                else:
                    default = (
                        " = None"
                        if optional
                        else (
                            " = field(default_factory=lambda: None)"
                            if ann == "Any"
                            else ""
                        )
                    )
                    if optional and not default:
                        default = " = None"
                    lines.append(f"    {field_name}: {ann}{default}")
            body = "\n".join(lines) or "    pass"
            self.defined[cls_name] = header + "\n" + body
            return cls_name

        if t == "list":
            if "child_type" in node:
                ct = (
                    self._map_prim(node["child_type"])
                    if node["child_type"] in self.MAP
                    else "Any"
                )
                return f"List[{ct}]"
            if "child" in node:
                child = node["child"]
                child_name = pascal_case(name + "Item")
                ct = self._render_node(child_name, child, pydantic=pydantic)
                return f"List[{ct}]"
            return "List[Any]"

        return self._map_prim(t)


class TypeScriptGenerator(Generator):
    """TypeScript generator."""

    MAP = {
        "str": "string",
        "int": "number",
        "float": "number",
        "bool": "boolean",
        "NoneType": "null | any",
        "unknown": "any",
        "mixed": "any",
        "conflict": "any",
        "timestamp": "string",
    }

    def _map_prim(self, t: str) -> str:
        return self.MAP.get(t, "any")

    def generate(self) -> str:
        self.defined.clear()
        root_type = self._render_node(self.root_name, self.schema)
        parts = ["// Generated by multi_schema_codegen", ""]
        for name in sorted(self.defined.keys()):
            parts.append(self.defined[name])
            parts.append("")

        if self.config.export_interfaces:
            parts.append(f"export type {self.root_name} = {root_type};")
        else:
            parts.append(f"type {self.root_name} = {root_type};")

        return "\n".join(parts)

    def _render_node(self, name: str, node: Dict[str, Any]) -> str:
        t = node["type"]
        if t == "object":
            iface_name = self.registry.register(name)
            if iface_name in self.defined:
                return iface_name

            export_keyword = "export " if self.config.export_interfaces else ""
            lines = [f"{export_keyword}interface {iface_name} {{"]

            for k, v in node.get("children", {}).items():
                safe_k = safe_field_name(k, ReservedKeywords.TYPESCRIPT)
                opt = "?" if v.get("optional") else ""
                ts_type = self._render_node(pascal_case(k), v)
                lines.append(f"  {safe_k}{opt}: {ts_type};")
            lines.append("}")
            self.defined[iface_name] = "\n".join(lines)
            return iface_name

        if t == "list":
            if "child_type" in node:
                return f"{self._map_prim(node['child_type'])}[]"
            if "child" in node:
                return f"{self._render_node(name + 'Item', node['child'])}[]"
            return "any[]"

        return self._map_prim(t)


class RustGenerator(Generator):
    """Rust generator with serde support."""

    MAP = {
        "str": "String",
        "int": "i64",
        "float": "f64",
        "bool": "bool",
        "NoneType": "Option<serde_json::Value>",
        "unknown": "serde_json::Value",
        "mixed": "serde_json::Value",
        "conflict": "serde_json::Value",
        "timestamp": "chrono::DateTime<chrono::Utc>",
    }

    def _map_prim(self, t: str) -> str:
        return self.MAP.get(t, "serde_json::Value")

    def generate(self) -> str:
        self.defined.clear()
        root_type = self._render_node(self.root_name, self.schema)
        parts = [
            "// Generated by multi_schema_codegen",
            "use serde::{Deserialize, Serialize};",
            "use chrono::{DateTime, Utc};",
            "",
        ]
        for name in sorted(self.defined.keys()):
            parts.append(self.defined[name])
            parts.append("")
        parts.append(f"// Root type alias\npub type {self.root_name} = {root_type};")
        return "\n".join(parts)

    def _render_node(self, name: str, node: Dict[str, Any]) -> str:
        t = node["type"]
        if t == "object":
            struct_name = self.registry.register(name)
            if struct_name in self.defined:
                return struct_name
            lines = [
                f"#[derive(Debug, Serialize, Deserialize, Clone)]",
                f"pub struct {struct_name} {{",
            ]
            for k, v in node.get("children", {}).items():
                field_name = safe_field_name(k, ReservedKeywords.RUST)
                rust_type = self._render_node(pascal_case(k), v)
                if v.get("optional"):
                    rust_type = f"Option<{rust_type}>"
                lines.append(f'    #[serde(rename = "{k}")]')
                lines.append(f"    pub {field_name}: {rust_type},")
            lines.append("}")
            self.defined[struct_name] = "\n".join(lines)
            return struct_name

        if t == "list":
            if "child_type" in node:
                return f"Vec<{self._map_prim(node['child_type'])}>"
            if "child" in node:
                child = node["child"]
                return f"Vec<{self._render_node(name + 'Item', child)}>"
            return "Vec<serde_json::Value>"

        return self._map_prim(t)


class OpenAPIGenerator(Generator):
    """OpenAPI 3 generator."""

    PRIMITIVE_MAP = {
        "str": {"type": "string"},
        "int": {"type": "integer", "format": "int64"},
        "float": {"type": "number", "format": "double"},
        "bool": {"type": "boolean"},
        "NoneType": {"nullable": True},
        "unknown": {"type": "object"},
        "mixed": {"type": "object"},
        "conflict": {"type": "object"},
        "timestamp": {"type": "string", "format": "date-time"},
    }

    def generate(self) -> str:
        self.components: Dict[str, Any] = {}
        root_ref = self._render_node(self.root_name, self.schema)
        openapi = {
            "openapi": "3.0.0",
            "info": {"title": "Generated API", "version": "1.0.0"},
            "components": {"schemas": self.components},
            "paths": {},
        }
        return json.dumps(openapi, indent=2)

    def _render_node(self, name: str, node: Dict[str, Any]) -> Dict[str, Any]:
        t = node["type"]
        if t == "object":
            schema_name = self.registry.register(name)
            if schema_name in self.components:
                return {"$ref": f"#/components/schemas/{schema_name}"}
            props = {}
            required = []
            for k, v in node.get("children", {}).items():
                prop_schema = self._render_node(pascal_case(k), v)
                props[k] = prop_schema
                if not v.get("optional"):
                    required.append(k)
            comp = {"type": "object", "properties": props}
            if required:
                comp["required"] = required
            self.components[schema_name] = comp
            return {"$ref": f"#/components/schemas/{schema_name}"}

        if t == "list":
            if "child_type" in node:
                return {
                    "type": "array",
                    "items": self.PRIMITIVE_MAP.get(
                        node["child_type"], {"type": "object"}
                    ),
                }
            if "child" in node:
                items = self._render_node(name + "Item", node["child"])
                return {"type": "array", "items": items}
            return {"type": "array", "items": {"type": "object"}}

        return self.PRIMITIVE_MAP.get(t, {"type": "object"})


class GraphQLGenerator(Generator):
    """GraphQL generator."""

    MAP = {
        "str": "String",
        "int": "Int",
        "float": "Float",
        "bool": "Boolean",
        "NoneType": "String",
        "unknown": "String",
        "mixed": "String",
        "conflict": "String",
        "timestamp": "String",
    }

    def _map_prim(self, t: str) -> str:
        return self.MAP.get(t, "String")

    def generate(self) -> str:
        self.defined.clear()
        root_type = self._render_node(self.root_name, self.schema)
        parts = ["# Generated by multi_schema_codegen\n"]
        for name in sorted(self.defined.keys()):
            parts.append(self.defined[name])
            parts.append("")
        parts.append(f"type Query {{\n  root: {root_type}\n}}")
        return "\n".join(parts)

    def _render_node(self, name: str, node: Dict[str, Any]) -> str:
        t = node["type"]
        if t == "object":
            type_name = self.registry.register(name)
            if type_name in self.defined:
                return type_name
            lines = [f"type {type_name} {{"]
            for k, v in node.get("children", {}).items():
                gql_type = self._render_node(pascal_case(k), v)
                nullable = v.get("optional")
                if not nullable:
                    gql_type += "!"
                lines.append(f"  {k}: {gql_type}")
            lines.append("}")
            self.defined[type_name] = "\n".join(lines)
            return type_name

        if t == "list":
            if "child_type" in node:
                return f"[{self._map_prim(node['child_type'])}]"
            if "child" in node:
                return f"[{self._render_node(name + 'Item', node['child'])}]"
            return "[String]"

        return self._map_prim(t)


# --------------------- MultiTargetGenerator ---------------------


class MultiTargetGenerator:
    """multi-target generator with configuration support."""

    SUPPORTED_TARGETS = {
        "go": GoGenerator,
        "python": PythonDataclassGenerator,
        "python-dataclasses": PythonDataclassGenerator,
        "pydantic": PythonDataclassGenerator,
        "typescript": TypeScriptGenerator,
        "ts": TypeScriptGenerator,
        "java": JavaGenerator,
        "rust": RustGenerator,
        "openapi": OpenAPIGenerator,
        "graphql": GraphQLGenerator,
    }

    def __init__(self, schema: Dict[str, Any], root_name: str = "Root"):
        self.schema = schema
        self.root_name = root_name

    def generate(
        self,
        target: str,
        config: Optional[Union[Dict[str, Any], GeneratorConfig]] = None,
    ) -> str:
        """Generate code for the specified target with optional configuration."""
        target = target.lower()

        if target not in self.SUPPORTED_TARGETS:
            available = ", ".join(sorted(self.SUPPORTED_TARGETS.keys()))
            raise ValueError(
                f"Unknown target: {target}. Available targets: {available}"
            )

        # Handle configuration
        if config is None:
            config = GeneratorConfig()
        elif isinstance(config, dict):
            config = GeneratorConfig.from_dict(config)

        # Special handling for Python targets
        if target == "pydantic":
            config.use_dataclasses = False
        elif target == "python-dataclasses":
            config.use_dataclasses = True

        generator_class = self.SUPPORTED_TARGETS[target]
        generator = generator_class(self.schema, self.root_name, config)

        try:
            return generator.generate()
        except Exception as e:
            logging.error(f"Error generating {target} code: {e}")
            raise

    def list_targets(self) -> List[str]:
        """Return list of supported target languages."""
        return sorted(self.SUPPORTED_TARGETS.keys())

    def generate_all(self, config: Optional[Dict[str, Any]] = None) -> Dict[str, str]:
        """Generate code for all supported targets."""
        results = {}
        base_targets = [
            "go",
            "java",
            "python",
            "pydantic",
            "typescript",
            "rust",
            "openapi",
            "graphql",
        ]

        for target in base_targets:
            try:
                results[target] = self.generate(target, config)
            except Exception as e:
                logging.warning(f"Failed to generate {target}: {e}")
                results[target] = f"// Error generating {target}: {e}"

        return results


# --------------------- CLI ---------------------


def parse_config_string(config_str: str) -> Dict[str, Any]:
    """Parse configuration string like 'lombok=true,jackson=false,package=com.example'."""
    config = {}
    if not config_str:
        return config

    for pair in config_str.split(","):
        if "=" not in pair:
            continue
        key, value = pair.split("=", 1)
        key = key.strip()
        value = value.strip()

        # Convert boolean strings
        if value.lower() in ("true", "false"):
            config[key] = value.lower() == "true"
        else:
            config[key] = value

    return config


def main():
    """CLI with better configuration support."""
    import argparse

    try:
        from analyzer import analyze_json
    except ImportError:
        print(
            "Error: analyzer.py module not found. Please ensure it's in the same directory."
        )
        return 1

    parser = argparse.ArgumentParser(
        description="Generate code from JSON schema",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --input data.json --target java --root User
  %(prog)s --input data.json --target java --config "lombok=true,jackson=true,package=com.example"
  %(prog)s --input data.json --target python --config "use_dataclasses=false"
  %(prog)s --input data.json --list-targets
        """,
    )

    parser.add_argument("--input", "-i", help="Input JSON data file")
    parser.add_argument(
        "--target",
        "-t",
        choices=list(MultiTargetGenerator.SUPPORTED_TARGETS.keys()),
        help="Target language/framework",
    )
    parser.add_argument(
        "--root", "-r", default="Root", help="Root type name (default: Root)"
    )
    parser.add_argument(
        "--config", "-c", help="Configuration string (key=value,key2=value2)"
    )
    parser.add_argument(
        "--list-targets",
        action="store_true",
        help="List all supported target languages",
    )
    parser.add_argument(
        "--generate-all",
        action="store_true",
        help="Generate code for all supported targets",
    )
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")

    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.WARNING)

    # Handle special commands
    gen = MultiTargetGenerator({})  # Dummy for listing targets

    if args.list_targets:
        print("Supported targets:")
        for target in gen.list_targets():
            print(f"  {target}")
        return 0

    if not args.input:
        parser.error("--input is required unless using --list-targets")

    if not args.target and not args.generate_all:
        parser.error("Either --target or --generate-all is required")

    # Load and analyze data
    try:
        with open(args.input, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception as e:
        print(f"Error reading input file: {e}")
        return 1

    try:
        schema = analyze_json(data)
    except Exception as e:
        print(f"Error analyzing JSON: {e}")
        return 1

    # Parse configuration
    config = parse_config_string(args.config or "")

    # Generate code
    gen = MultiTargetGenerator(schema, root_name=args.root)

    try:
        if args.generate_all:
            results = gen.generate_all(config)
            for target, code in results.items():
                print(f"\n{'='*50}")
                print(f"TARGET: {target.upper()}")
                print("=" * 50)
                print(code)
        else:
            output = gen.generate(args.target, config)
            print(output)
    except Exception as e:
        print(f"Error generating code: {e}")
        return 1

    return 0


if __name__ == "__main__":
    exit(main())
